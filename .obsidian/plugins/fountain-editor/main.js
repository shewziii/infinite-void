/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source, visit the plugin's github repository
*/

'use strict';

var state = require('@codemirror/state');
var obsidian = require('obsidian');
var view = require('@codemirror/view');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const TOKEN_NAMES = {
    sceneHeading: "scene-heading",
    action: "action",
    character: "character",
    dialogue: "dialogue",
    parenthetical: "parenthetical",
    lyrics: "lyrics",
    centered: "centered",
    transition: "transition",
    section: "section",
    synopsis: "synopsis",
    boneyard: "boneyard",
    fBoneyardStart: "formatting-boneyard-start",
    fBoneyardEnd: "formatting-boneyard-end",
    pageBreak: "page-break",
};
const n = TOKEN_NAMES;
const LINE_TOKENS = [
    {
        id: n.sceneHeading,
        regex: /^((?:\*{0,3}_?)?(?:int|ext|est|i\/e|int\/ext)[. ].+)|^\.(?!\.+)(.+)/i,
    },
    {
        id: n.action,
        regex: /^!.*$/,
    },
    {
        id: n.character,
        regex: /^[^\S\r\n]*(?=.*[A-Z\u00C0-\u00DEF])[A-Z\d\u00C0-\u00DEF \t'.-]+\s?(\(.*\))?$|@.*$/,
    },
    {
        id: n.dialogue,
        regex: /^[^\S\r\n]*(\^?)?\n(?!\n+)([\s\S]+)/,
    },
    {
        id: n.parenthetical,
        regex: /^[^\S\r\n]*(\(.+\))$/,
    },
    {
        id: n.lyrics,
        regex: /^~.*$/,
    },
    {
        id: n.centered,
        regex: /^[^\S\r\n]*>[^<>]+<$/,
    },
    {
        id: n.transition,
        regex: /^[^\S\r\n]*(>[^<\n\r]*|[A-Z ]+ TO:)$/,
    },
    {
        id: n.section,
        regex: /^(#+) *(.*)/,
    },
    {
        id: n.synopsis,
        regex: /^=(?!=+) *(.*)$/,
    },
    // Note: /^(?:\[{2}(?!\[+))(.+)(?:\]{2}(?!\[+))$/,
    // note_inline: /(?:\[{2}(?!\[+))([\s\S]+?)(?:\]{2}(?!\[+))/g,
    // boneyard: /(^\/\*|^\*\/)$/g,
    {
        id: n.fBoneyardStart,
        regex: /(^\/\*$)/g,
    },
    {
        id: n.fBoneyardEnd,
        regex: /(^\*\/$)/g,
    },
    {
        id: n.pageBreak,
        regex: /^={3,}$/,
    },
];

function composeFntClass(t) {
    return `cm-formatting cm-fountain-formatting-${t}`;
}
function handleEmptyLine(line, state) {
    if (line.trim()) {
        return false;
    }
    // At least two spaces to be considered
    // https://fountain.io/syntax#line-breaks
    if (line.length < 2) {
        state.inDialogue = false;
    }
    return true;
}
/** Skip formatting within %% comments */
function handleCommentBlock(line, state) {
    if (state.inCommentBlock) {
        if (line.includes("%%")) {
            state.inCommentBlock = false;
        }
        return true;
    }
    if (line.includes("%%")) {
        state.inCommentBlock = true;
        return true;
    }
    return false;
}
function handleToken(tId, state, context) {
    if (tId === TOKEN_NAMES.fBoneyardEnd) {
        state.inBoneyard = false;
    }
    if (state.inBoneyard) {
        return TOKEN_NAMES.boneyard;
    }
    if (tId === TOKEN_NAMES.fBoneyardStart) {
        state.inDialogue = false;
        state.inBoneyard = true;
    }
    if (tId === TOKEN_NAMES.character) {
        if (context.afterEmptyLine &&
            !context.beforeEmptyLine &&
            !context.isLastLine) {
            state.inDialogue = true;
        }
        else {
            return null;
        }
    }
    if (tId === TOKEN_NAMES.parenthetical && !state.inDialogue) {
        return null;
    }
    if (tId === TOKEN_NAMES.transition &&
        !(context.afterEmptyLine && context.beforeEmptyLine)) {
        return null;
    }
    return tId;
}
function getLineFormat(line, state, context, settings) {
    if (handleEmptyLine(line, state)) {
        return null;
    }
    if (handleCommentBlock(line, state)) {
        return null;
    }
    for (const { id: tId, regex: tRegex } of LINE_TOKENS) {
        if (tRegex.test(line)) {
            const token = handleToken(tId, state, context);
            // setting to early exit on transition-blockquotes
            if (settings.preferObsidianBlockquote &&
                token === TOKEN_NAMES.transition &&
                line.startsWith(">")) {
                return null;
            }
            if (token !== null) {
                return token;
            }
        }
    }
    if (state.inDialogue) {
        return TOKEN_NAMES.dialogue;
    }
    if (state.inBoneyard) {
        return TOKEN_NAMES.boneyard;
    }
    if (line.startsWith(">"))
        return null;
    return TOKEN_NAMES.action;
}
function buildDecorations(view$1, isFountainStateField, settings) {
    const isFountain = view$1.state.field(isFountainStateField, false);
    if (!isFountain) {
        return view.Decoration.none;
    }
    const builder = new state.RangeSetBuilder();
    function markDeco(start, end, className) {
        const deco = view.Decoration.mark({ class: className });
        builder.add(start, end, deco);
    }
    const state$1 = {
        inDialogue: false,
        inBoneyard: false,
        inCommentBlock: false,
    };
    for (const { from, to } of view$1.visibleRanges) {
        const visibleText = view$1.state.sliceDoc(from, to);
        const maxLines = view$1.state.doc.lines;
        for (let pos = from; pos <= to;) {
            const line = view$1.state.doc.lineAt(pos);
            const { from: lFrom, to: lTo, text: lText } = line;
            const relativeFrom = lFrom - from;
            const relativeTo = lTo - from;
            const context = {
                afterEmptyLine: visibleText[relativeFrom - 2] === "\n",
                beforeEmptyLine: visibleText[relativeTo + 1] === "\n",
                isLastLine: line.number === maxLines,
            };
            const token = getLineFormat(lText, state$1, context, settings);
            if (!token) {
                pos = lTo + 1;
                continue;
            }
            const deco = view.Decoration.line({ class: "cm-fountain-" + token });
            builder.add(lFrom, lFrom, deco);
            // Mark Decorations
            const firstChar = lText[0];
            const lastChar = lText[line.length - 1];
            // action
            if (token === TOKEN_NAMES.action && firstChar === "!" && !lText.startsWith("![[")) {
                markDeco(lFrom, lFrom + 1, composeFntClass(token));
            }
            // scene heading
            if (token === TOKEN_NAMES.sceneHeading && firstChar === ".") {
                markDeco(lFrom, lFrom + 1, composeFntClass(token));
            }
            // lyric
            if (token === TOKEN_NAMES.lyrics && firstChar === "~") {
                markDeco(lFrom, lFrom + 1, composeFntClass(token));
            }
            // synopsis
            if (token === TOKEN_NAMES.synopsis && firstChar === "=") {
                markDeco(lFrom, lFrom + 2, composeFntClass(token));
            }
            // character
            if (token === TOKEN_NAMES.character) {
                // forced character
                if (firstChar === "@") {
                    markDeco(lFrom, lFrom + 1, composeFntClass(token));
                }
                // character extension
                if (lastChar === ")") {
                    const charExtension = lText.match(/(\(.*\))?$/g);
                    if (charExtension === null) {
                        console.error("Character regex broken; char ext segment should exist");
                        continue;
                    }
                    const charExtensionLength = charExtension[0].length;
                    const charExtensionStart = lTo - charExtensionLength;
                    markDeco(charExtensionStart, lTo, "cm-fountain-character-extension");
                }
            }
            // centered
            if (token === TOKEN_NAMES.centered && lastChar === "<") {
                markDeco(lTo - 1, lTo, composeFntClass(token));
            }
            pos = lTo + 1;
        }
    }
    return builder.finish();
}

/* ------------------------------------ - ----------------------------------- */
const updateIsFountainState = state.StateEffect.define();
const isFountainStateField = state.StateField.define({
    create() {
        return false;
    },
    update(value, tr) {
        for (const effect of tr.effects) {
            if (effect.is(updateIsFountainState)) {
                return effect.value;
            }
        }
        return value;
    },
});
function updateFileState({ app, hasTag }) {
    const markdownView = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    if (!markdownView || !("cm" in markdownView.editor))
        return;
    const cmEditor = markdownView.editor.cm;
    cmEditor.dispatch({ effects: updateIsFountainState.of(hasTag) });
}
/* ------------------------------------ - ----------------------------------- */
let FountainPlugin$1 = class FountainPlugin {
    constructor(view$1, settings) {
        this.settings = settings;
        this.decorations = view$1.state.field(isFountainStateField)
            ? buildDecorations(view$1, isFountainStateField, settings)
            : view.Decoration.none;
    }
    update(update) {
        const shouldBuildDecorations = update.docChanged ||
            update.viewportChanged ||
            update.startState.field(isFountainStateField) !==
                update.state.field(isFountainStateField);
        if (shouldBuildDecorations) {
            this.decorations = buildDecorations(update.view, isFountainStateField, this.settings);
        }
    }
};
function fountainPlugin(settings) {
    const plugin = view.ViewPlugin.fromClass(class extends FountainPlugin$1 {
        constructor(view) {
            super(view, settings);
        }
    }, { decorations: (value) => value.decorations });
    return [isFountainStateField, plugin];
}

const DEFAULT_SETTINGS = {
    fixMinimal: false,
    preferObsidianBlockquote: false,
};
const themeFixClass = "fountain-theme-fix";
const setFixThemeState = {
    add() {
        document.body.classList.add(themeFixClass);
    },
    remove() {
        document.body.classList.remove(themeFixClass);
    },
};
class FountainEditorSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        const { containerEl } = this;
        containerEl.empty();
        containerEl.createEl("h2", { text: "Fountain Editor Settings" });
        new obsidian.Setting(containerEl)
            .setName("Fix broken styling on certain themes")
            .setDesc("Fix Fountain formatting on themes like Minimal.")
            .addToggle((toggle) => toggle
            .setValue(this.plugin.settings.fixMinimal)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.fixMinimal = value;
            yield this.plugin.saveSettings();
            // Add or remove the class
            if (value) {
                setFixThemeState.add();
            }
            else {
                setFixThemeState.remove();
            }
        })));
        new obsidian.Setting(containerEl)
            .setName("Prefer Obsidian's blockquote over Fountain's forced Transition")
            .setDesc("Skips trying to convert single-lines that start with `>` from Obsidian blockquotes into Fountain's Transitions. Blockquotes are the preferred cleaner way to annotate your screenplay, but you will need to strip them out before rendering your Fountain document to PDF.")
            .addToggle((toggle) => toggle
            .setValue(this.plugin.settings.preferObsidianBlockquote)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.preferObsidianBlockquote = value;
            yield this.plugin.saveSettings();
        })));
    }
}

function onMetadataChanged(app, file) {
    const activeFile = getActiveMarkdownFile(app);
    if (activeFile && activeFile.path === file.path) {
        updateClass(app);
    }
}
function updateClass(app) {
    var _a, _b;
    const file = getActiveMarkdownFile(app);
    if (!file) {
        toggleClass(app, false);
        return;
    }
    if (file.extension === "fountain" || file.basename.endsWith(".fountain")) {
        toggleClass(app, true);
        return;
    }
    const metadata = app.metadataCache.getFileCache(file);
    if ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.frontmatter) === null || _a === void 0 ? void 0 : _a.tags) {
        const tags = metadata.frontmatter.tags;
        if (tags.includes("fountain")) {
            toggleClass(app, true);
            return;
        }
    }
    if ((_b = metadata === null || metadata === void 0 ? void 0 : metadata.frontmatter) === null || _b === void 0 ? void 0 : _b.cssclasses) {
        const cssclasses = metadata.frontmatter.cssclasses;
        if (cssclasses.includes("fountain")) {
            toggleClass(app, true);
            return;
        }
    }
    toggleClass(app, false);
}
function toggleClass(app, add) {
    const view = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    const sourceView = view === null || view === void 0 ? void 0 : view.containerEl.querySelector(".markdown-source-view");
    updateFileState({ app, hasTag: add });
    if (!sourceView)
        return;
    sourceView.classList.toggle("fountain", add);
}
function getActiveMarkdownFile(app) {
    var _a;
    const view = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    return (_a = view === null || view === void 0 ? void 0 : view.file) !== null && _a !== void 0 ? _a : undefined;
}

new state.Compartment();
class FountainPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            /* ---------------------------- settings -------------------------------- */
            yield this.loadSettings();
            this.addSettingTab(new FountainEditorSettingTab(this.app, this));
            // Apply the classname on load if the setting is enabled
            if (this.settings.fixMinimal) {
                setFixThemeState.add();
            }
            /* ------------------------ editor extension ---------------------------- */
            // this.registerEditorExtension(fountainPlugin);
            this.registerEditorExtension(fountainPlugin(this.settings));
            // Ensure `fountain` class is added to relevant leaves
            this.app.workspace.on("active-leaf-change", () => {
                updateClass(this.app);
            });
            this.app.workspace.on("file-open", () => {
                updateClass(this.app);
            });
            this.app.metadataCache.on("changed", (file) => {
                onMetadataChanged(this.app, file);
            });
            updateClass(this.app);
        });
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, (yield this.loadData()));
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
    onunload() {
        this.app.metadataCache.off("changed", (file) => {
            onMetadataChanged(this.app, file);
        });
        updateClass(this.app);
        // Remove the classname when the plugin is unloaded
        setFixThemeState.remove();
    }
}

module.exports = FountainPlugin;


/* nosourcemap */